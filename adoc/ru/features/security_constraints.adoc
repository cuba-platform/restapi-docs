:sourcesdir: ../../../source

[[rest_api_v2_security_constraints]]
=== Ограничения для атрибутов-коллекций

Рассмотрим следующую ситуацию:

* Модель данных содержит сущности `Order` и `OrderLine`, образующие one-to-many композицию.

* Некоторый REST-клиент загружает экземпляр `Order` вместе с вложенной коллекцией экземпляров `OrderLine`.

* Существуют {manual}/constraints.html[ограничения безопасности], которые отфильтровывают некоторые экземпляры `OrderLine` так, что клиент не загружает их и не знает об их существовании. Допустим, строка `line5` не загружена клиентом, но существует в базе данных.

* Если клиент удаляет из коллекции некоторую строку, скажем, `line2`, и сохраняет всю композицию с помощью запроса на `/entities/{entityName}/{entityId}`, то возможны два исхода:
+
--
. Если ограничения не были изменены с момента загрузки объектов, фреймворк восстанавливает отфильтрованный элемент коллекции `line5` и удаляет только `line2`, что является корректным поведением.

. Если ограничения были изменены таким образом что `line5` стал доступным клиенту, фреймворк не может корректно восстановить информацию об отфильтрованных элементах коллекции. В результате будут удалены оба элемента: `line2` и `line5`.
--

Если в вашем приложении подобная ситуация возможна, то избежать потери данных можно путем пересылки в JSON специального системного атрибута. Данный атрибут имеет имя `+__securityToken+` и автоматически включается в результирующий JSON если свойство приложения <<cuba.rest.requiresSecurityToken,cuba.rest.requiresSecurityToken>> установлено в true. В этом случае в обязанности вашего REST-клиента входит передача этого атрибута обратно при сохранении сущности.

Пример JSON сущности с включенным security token:

[source, json]
----
include::{sourcesdir}/features/securityToken.json[]
----

Атрибут `+__securityToken+` содержит закодированные идентификаторы отфильтрованных экземпляров, так что фреймворк всегда может восстановить необходимую информацию независимо от изменений в настройках ограничений.

